<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: contracts-functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">contracts-functions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="function-contracts"></a>
Function Contracts</h1>
<p>CBMC offers support for function contracts, which includes three basic clauses: <em>requires</em>, <em>ensures</em>, and <em>assigns</em>. These clauses formally describe the specification of a function. CBMC also provides a series of built-in constructs to be used with functions contracts (e.g., <em>history variables</em>, <em>quantifiers</em>, and <em>memory predicates</em>).</p>
<p>When a function contract is checked, the tool automatically havocs all static variables of the program (to start the analysis in an arbitrary state), in the same way as using <code>--nondet-static</code> would do. If one wishes not to havoc some static variables, then <code>--nondet-static-exclude name-of-variable</code> can be used. ## Overview</p>
<p>Take a look at the example below.</p>
<div class="fragment"><div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line">#include &lt;stdint.h&gt;</div>
<div class="line"> </div>
<div class="line">#define SUCCESS 0</div>
<div class="line">#define FAILURE -1</div>
<div class="line"> </div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">  int rval = sum(a, b, &amp;out);</div>
<div class="line">  if (rval == SUCCESS)</div>
<div class="line">    return out;</div>
<div class="line">  return rval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Function <code>sum</code> writes the sum of <code>a</code> and <code>b</code> to <code>out</code>, and returns <code>SUCCESS</code>; unless the result of the addition is too large to be represented as an <code>uint32_t</code>, in which case it returns <code>FAILURE</code>. Letâ€™s write a function contract for this function.</p>
<p>A function contract has three parts:</p>
<ul>
<li><b>Precondition</b> - describes what the function requires of the arguments supplied by the caller and of global variables;</li>
<li><b>Postcondition</b> - describes the effect of the function;</li>
<li><b>Write Set</b> - describes the set of locations outside the function that might be written to.</li>
</ul>
<p>In our example, the developer may require from the caller to properly allocate all arguments, thus, pointers must be valid. We can specify the preconditions of a function using <code>__CPROVER_requires</code> (see <a class="el" href="md_contracts-requires-and-ensures.html">Requires &amp; Ensures Clauses</a> for details) and we can specify an allocated object using a predicate called <code>__CPROVER_is_fresh</code> (see <a class="el" href="md_contracts-memory-predicates.html">Memory Predicate</a> for details). Thus, for the <code>sum</code> function, the set of preconditions are</p>
<div class="fragment"><div class="line">/* Precondition */</div>
<div class="line">__CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out)))</div>
</div><!-- fragment --><p>We can use <code>__CPROVER_ensures</code> to specify postconditions (see <a class="el" href="md_contracts-requires-and-ensures.html">Requires &amp; Ensures Clauses</a> for details). In our example, developers can use the built-in construct <code>__CPROVER_return_value</code>, which represents the return value of a function. As postconditions, one may list possible return values (in this case, either <code>SUCCESS</code> or <code>FAILURE</code>) as well as describe the main property of this function: if the function returns <code>SUCCESS</code>, then <code>*out</code> stores the result of <code>a + b</code>. We can also check that the value in <code>*out</code> will be preserved in case of failure by using <code>__CPROVER_old</code>, which refers to the value of a given object in the pre-state of a function (see <a class="el" href="md_contracts-history-variables.html">History Variables</a> for details). Thus, for the <code>sum</code> function, the set of postconditions are</p>
<div class="fragment"><div class="line">/* Postconditions */</div>
<div class="line">__CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE)</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b)))</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == FAILURE) ==&gt; (*out == __CPROVER_old(*out)))</div>
</div><!-- fragment --><p>Finally, the <em>assigns</em> clause allows developers to define a frame condition (see <a class="el" href="md_contracts-assigns.html">Assigns Clause</a> for details). In general, systems for describing the frame condition of a function use either writes or modifies semantics; this design is based on the former. This means that memory not specified by the assigns clause must not be written within the given function scope, even if the value(s) therein are not modified. In our example, since we expect that only the value that <code>out</code> points to may be modified, we annotate the function using <code>__CPROVER_assigns(*out)</code>.</p>
<div class="fragment"><div class="line">/* Write Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
</div><!-- fragment --><p>Here is the whole function with its contract.</p>
<div class="fragment"><div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">/* Precondition */</div>
<div class="line">__CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out)))</div>
<div class="line">/* Postconditions */</div>
<div class="line">__CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE)</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b)))</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == FAILURE) ==&gt; (*out == __CPROVER_old(*out)))</div>
<div class="line">/* Write Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>First, we have to prove that the function satisfies the contract.</p>
<div class="fragment"><div class="line">goto-cc -o sum.goto *.c --function sum</div>
<div class="line">goto-instrument --enforce-contract sum sum.goto sum-checking-contracts.goto</div>
<div class="line">cbmc sum-checking-contracts.goto --function sum</div>
</div><!-- fragment --><p>The first command just compiles the GOTO program as usual, the second command instruments the code to check the function satisfies the contract, and the third one runs CBMC to do the checking.</p>
<p>Now that we have proved that the function satisfies the contract, we can use the function contract in place of the function implementation wherever the function is called.</p>
<div class="fragment"><div class="line">goto-cc -o foo.goto *.c --function foo</div>
<div class="line">goto-instrument --replace-call-with-contract sum foo.goto foo-using-sum-contract.goto</div>
<div class="line">cbmc foo-using-sum-contract.goto --function foo</div>
</div><!-- fragment --><p>The first command just compiles the GOTO program as usual, the second command instruments the code to use the function contract in place of the function implementation wherever is invoked, and the third one runs CBMC to check the program using contracts.</p>
<h2><a class="anchor" id="additional-resources"></a>
Additional Resources</h2>
<ul>
<li><a class="el" href="md_contracts-requires-and-ensures.html">Requires &amp; Ensures Clauses</a></li>
<li><a class="el" href="md_contracts-assigns.html">Assigns Clause</a></li>
<li><a class="el" href="md_contracts-memory-predicates.html">Memory Predicates</a></li>
<li><a class="el" href="md_contracts-history-variables.html">History Variables</a></li>
<li><a class="el" href="md_contracts-quantifiers.html">Quantifiers</a></li>
</ul>
<p>Last modified: 2022-09-26 10:26:46 +0100 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
