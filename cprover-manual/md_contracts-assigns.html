<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CProver manual: contracts-assigns</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CProver manual
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">contracts-assigns </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href=".">CPROVER Manual TOC</a></p>
<h1><a class="anchor" id="assigns-clauses"></a>
Assigns Clauses</h1>
<p>An <em>assigns clause</em> lets the user to specify which memory locations may be assigned to by a function or a loop.</p>
<p>Knowing the memory footprint of a function contract or a loop contract in turn allows us to replace a function call or a loop by an nondeterministic approximation in which assignable locations are havoced. To make sure this approximation is sound and is an actual abstraction of the original function call or loop, we need to verify that the actual function or loop never assigns memory locations not listed in the clause.</p>
<p>For a function contract, if no assigns clause is provided, the default is the empty set. For a loop contract, if no assigns clause is provided, CBMC attempts to infer the set of locations assigned by the loop from the loop body, and then checks that the inferred set is correct (as if specified by the user).</p>
<p>For both functions and loop contracts, if more than one assigns clause is provided, their contents are unioned into a single clause.</p>
<p>We use the <em>assigns</em> interpretation for these memory locations, which means that memory locations that are not listed in the assigns clause (or the <em>inferred</em> assigns clause for a loop contract) must not be assigned to by the function (or the loop), even if they end up holding the same value as they held before the function call (or before entering the loop).</p>
<p>Memory locations that are locally stack- or heap-allocated during function execution or loop execution can always be assigned to by the function or the loop.</p>
<h2><a class="anchor" id="syntax"></a>
Syntax</h2>
<div class="fragment"><div class="line">__CPROVER_assigns(targets)</div>
</div><!-- fragment --><p>Where <code>targets</code> has the following syntax: </p><pre class="fragment">targets           ::= cond-target-group (';' cond-target-group)* ';'?
cond-target-group ::= (condition ':')? target (',' target)*
target            ::= lvalue-expr
                    | __CPROVER_typed_target(lvalue-expr)
                    | __CPROVER_object_whole(ptr-expr)
                    | __CPROVER_object_from(ptr-expr)
                    | __CPROVER_object_upto(ptr-expr, uint-expr)
</pre><p>For function contracts, the condition and target expressions in the assigns clause may only involve function parameters, global variables or type identifiers (in <code>sizeof</code> or cast expressions). The target expression must be free of function calls and side-effects. The condition expression may contain calls to side-effect-free functions.</p>
<p>For a loop contract, the condition and target expressions in the assigns clause may involve any identifier that is in scope at loop entry (parameters of the surrounding function, local variables, global variables, type identifiers in <code>sizeof</code> or cast expressions, etc.). The target expression must be free of function calls and side-effects. The condition expression may contain calls to side-effect-free functions.</p>
<h3><a class="anchor" id="lvalue-targets"></a>
Lvalue targets</h3>
<p>Roughly speaking, <em>lvalues</em> are expressions that are associated with a memory location, the address of which can be computed using the address-of operator <code>&amp;</code>.</p>
<p>Examples of lvalues are: <code>x</code> if <code>x</code> is either a global or local variable identifier, <code>*ptr</code> if <code>ptr</code> is a pointer expression, <code>ptr[i]</code> or <code>ptr + i</code> if <code>ptr</code> is pointer variable or an array and <code>i</code> is an integer expression, etc.</p>
<p>Examples of non-lvalues: literal constants like <code>0</code>, <code>1</code>, …, arithmetic expressions like <code>x + y</code> when <code>x</code> and <code>y</code> are both arithmetic variables, function pointer expressions, etc.</p>
<p>An lvalue target <code>expr</code> with a complete type <code>expr_t</code> specifies that the range starting at <code>&amp;expr</code> and of size <code>sizeof(expr_t)</code> bytes is assignable.</p>
<p>Lvalues can also be wrapped in <code>__CPROVER_typed_target</code> with the same meaning: for an lvalue <code>expr</code> with a complete type <code>expr_t</code>, <code>__CPROVER_typed_target(expr)</code> specifies that the range of <code>sizeof(expr_t)</code> bytes starting at <code>&amp;expr</code> is assignable:</p>
<div class="fragment"><div class="line">void __CPROVER_typed_target(expr_t expr);</div>
</div><!-- fragment --><p>In order to specify that a memory location the contents of which is interpreted as a pointer by the program is assignable, one must use the notation <code>__CPROVER_assigns(ptr)</code> or the equivalent <code>__CPROVER_assigns(__CPROVER_typed_target(ptr))</code>, as opposed to the slice operators <code>__CPROVER_object_whole</code>, <code>__CPROVER_object_from</code>, or <code>__CPROVER_object_upto</code>. This ensures that during call-by-contract replacement the memory location gets turned into a non-deterministic pointer.</p>
<p>For instance:</p>
<div class="fragment"><div class="line">struct circular_buffer_t {</div>
<div class="line">  int *first;</div>
<div class="line">  int *last;</div>
<div class="line">  int *current;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void step(struct circular_buffer_t *buf)</div>
<div class="line">// correct</div>
<div class="line">__CPROVER_assigns(__CPROVER_typed_target(buf-&gt;current))</div>
<div class="line">// not correct</div>
<div class="line">__CPROVER_assigns(__CPROVER_object_upto(&amp;(buf-&gt;current), sizeof(buf-&gt;current))</div>
<div class="line">{</div>
<div class="line">  if(buf-&gt;current == buf-&gt;last)</div>
<div class="line">    buf-&gt;current = buf-&gt;first;</div>
<div class="line">  else</div>
<div class="line">    buf-&gt;current += 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="object-slice-targets"></a>
Object slice targets</h3>
<div class="fragment"><div class="line">void __CPROVER_object_upto(void *ptr, __CPROVER_size_t size);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_upto(ptr, size)</code> specifies that the range of <code>size</code> bytes starting at <code>ptr</code> is assignable.</p>
<p>The value of <code>size</code> must such that the range does not exceed the object’s boundary, i.e. <code>size &lt;= __CPROVER_OBJECT_SIZE(ptr) - __CPROVER_POINTER_OFFSET(ptr)</code> must hold (otherwise an assertion violation will occur and make the whole analysis fail).</p>
<p>In the example below, the <code>struct vect_t</code>, its <code>data</code> array and an exta hidden byte are packed together in a single object by the <code>vec_alloc</code> function. The <code>vec_clear</code> function can only assign <code>vec-&gt;size</code> bytes starting from <code>vec-&gt;data</code>. As a result the assignments to <code>vec-&gt;size</code> and the hidden byte fail the verification.</p>
<div class="fragment"><div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line"> </div>
<div class="line">#define MAX_SIZE 10</div>
<div class="line"> </div>
<div class="line">struct vec_t {</div>
<div class="line">  size_t size;</div>
<div class="line">  char *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Allocates a vect_t struct together with its data and a hidden byte</div>
<div class="line">// in a same object.</div>
<div class="line">struct vec_t *vec_alloc(size_t size) {</div>
<div class="line"> </div>
<div class="line">  if(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  // allocate the struct + data + 1 extra hidden byte</div>
<div class="line">  struct vec_t *vec = malloc(sizeof(struct vec_t) + size + 1);</div>
<div class="line">  if (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((char *)vec) + sizeof(struct vec_t);</div>
<div class="line">  }</div>
<div class="line">  return vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Clear the vec-&gt;data array</div>
<div class="line">void vec_clear(struct vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: __CPROVER_object_upto(vec-&gt;data, vec-&gt;size))</div>
<div class="line">{</div>
<div class="line">  if (!vec)</div>
<div class="line">    return;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; // FAILURE</div>
<div class="line"> </div>
<div class="line">  for (size_t i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; // SUCCESS</div>
<div class="line"> </div>
<div class="line">  char *hidden_byte = ((char *)vec + sizeof(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; // FAILURE</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Proof harness</div>
<div class="line">int main() {</div>
<div class="line">  size_t size;</div>
<div class="line">  struct vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<div class="fragment"><div class="line">void __CPROVER_object_from(void *ptr);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_from(ptr)</code> specifies that the range of bytes starting at <code>ptr</code> and of size <code>__CPROVER_OBJECT_SIZE(ptr) - __CPROVER_POINTER_OFFSET(ptr)</code> is assignable.</p>
<p>Revisiting our previous example, changing the target to <code>__CPROVER_object_from(vec-&gt;data)</code> still rejects the assignment to <code>vec-&gt;size</code>, but allows the assignment to the hidden byte which is located after the data array in memory.</p>
<div class="fragment"><div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line"> </div>
<div class="line">#define MAX_SIZE 10</div>
<div class="line"> </div>
<div class="line">struct vec_t {</div>
<div class="line">  size_t size;</div>
<div class="line">  char *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Allocates a vect_t struct together with its data and a hidden byte</div>
<div class="line">// in a same object.</div>
<div class="line">struct vec_t *vec_alloc(size_t size) {</div>
<div class="line"> </div>
<div class="line">  if(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  // allocate the struct + data + 1 extra hidden byte</div>
<div class="line">  struct vec_t *vec = malloc(sizeof(struct vec_t) + size + 1);</div>
<div class="line">  if (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((char *)vec) + sizeof(struct vec_t);</div>
<div class="line">  }</div>
<div class="line">  return vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Clear the vec-&gt;data array</div>
<div class="line">void vec_clear(struct vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: __CPROVER_object_from(vec-&gt;data))</div>
<div class="line">{</div>
<div class="line">  if (!vec)</div>
<div class="line">    return;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; // FAILURE</div>
<div class="line"> </div>
<div class="line">  for (size_t i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; // SUCCESS</div>
<div class="line"> </div>
<div class="line">  char *hidden_byte = ((char *)vec + sizeof(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; // SUCCESS</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Proof harness</div>
<div class="line">int main() {</div>
<div class="line">  size_t size;</div>
<div class="line">  struct vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<div class="fragment"><div class="line">void __CPROVER_object_whole(void *ptr);</div>
</div><!-- fragment --><p>Given a pointer <code>ptr</code> pointing into some object (possibly at some non-zero offset), <code>__CPROVER_object_whole(ptr)</code> specifies that the range of bytes of size <code>__CPROVER_OBJECT_SIZE(ptr)</code> starting at address <code>ptr - __CPROVER_POINTER_OFFSET(ptr)</code> is assignable:</p>
<p>If the pointer has a positive offset into some object, the range includes bytes that are in the object before the address pointed to by <code>ptr</code>. Revisiting our example one last time, changing the target to <code>__CPROVER_object_whole(vec-&gt;data)</code> allows the function (perhaps mistakenly) to assign to <code>vec-&gt;size</code>, the whole array of size <code>vec-&gt;size</code> pointed to by <code>vec-&gt;data</code> and the hidden byte.</p>
<div class="fragment"><div class="line">#include &lt;stdlib.h&gt;</div>
<div class="line"> </div>
<div class="line">#define MAX_SIZE 10</div>
<div class="line"> </div>
<div class="line">struct vec_t {</div>
<div class="line">  size_t size;</div>
<div class="line">  char *data;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// Allocates a vect_t struct together with its data and a hidden byte</div>
<div class="line">// in a same object.</div>
<div class="line">struct vec_t *vec_alloc(size_t size) {</div>
<div class="line"> </div>
<div class="line">  if(size &gt; MAX_SIZE)</div>
<div class="line">    size = MAX_SIZE;</div>
<div class="line"> </div>
<div class="line">  // allocate the struct + data + 1 extra hidden byte</div>
<div class="line">  struct vec_t *vec = malloc(sizeof(struct vec_t) + size + 1);</div>
<div class="line">  if (vec) {</div>
<div class="line">    vec-&gt;size = size;</div>
<div class="line">    vec-&gt;data = ((char *)vec) + sizeof(struct vec_t);</div>
<div class="line">  }</div>
<div class="line">  return vec;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Clear the vec-&gt;data array</div>
<div class="line">void vec_clear(struct vec_t *vec)</div>
<div class="line">  __CPROVER_assigns(</div>
<div class="line">    vec &amp;&amp; vec-&gt;data: __CPROVER_object_whole(vec-&gt;data))</div>
<div class="line">{</div>
<div class="line">  if (!vec)</div>
<div class="line">    return;</div>
<div class="line"> </div>
<div class="line">  vec-&gt;size = vec-&gt;size; // SUCCESS</div>
<div class="line"> </div>
<div class="line">  for (size_t i = 0; i &lt; vec-&gt;size; i++)</div>
<div class="line">    vec-&gt;data[i] = 0; // SUCCESS</div>
<div class="line"> </div>
<div class="line">  char *hidden_byte = ((char *)vec + sizeof(*vec) + vec-&gt;size);</div>
<div class="line">  *hidden_byte = 0; // SUCCESS</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Proof harness</div>
<div class="line">int main() {</div>
<div class="line">  size_t size;</div>
<div class="line">  struct vec_t *vec = vec_alloc(size);</div>
<div class="line">  vec_clear(vec);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="function-parameters"></a>
Function parameters</h3>
<p>For a function contract, the memory locations storing function parameters are considered as being local to the function and are hence always assignable.</p>
<p>For a loop contract, the parameters of the enclosing function are not considered local to the loop and must be explicitly added to the loop to become assignable. ### Inductive data structures Inductive data structures are not supported yet in assigns clauses.</p>
<h2><a class="anchor" id="semantics"></a>
Semantics</h2>
<p>Each target listed in an assigns clause defines a <em>conditionally assignable range</em> of bytes represented by the following triple:</p>
<div class="fragment"><div class="line">struct {</div>
<div class="line">  void *start_address;</div>
<div class="line">  size_t size;</div>
<div class="line">  bool is_writable;</div>
<div class="line">}</div>
</div><!-- fragment --><p>where: - <code>start_address</code> is the start address of the range of bytes, - <code>size</code> is the size of the range in number of bytes, - <code>is_writable</code> is true iff the target’s <code>condition</code> holds and <code>__CPROVER_w_ok(start_address, size)</code> holds at the program location where the clause is interpreted: right before function invocation for function contracts and at loop entry for loops;</p>
<p>For contract enforcement, assigns clause targets are turned into checks, to verify that the function only assigns locations allowed by the assigns clause.</p>
<p>For contract replacement, assigns clause targets are turned into havoc statements, to model the non-deterministic behaviour specified by the contract. ### Contract Enforcement</p>
<p>In order to determine whether a function (or loop) complies with the <em>assigns</em> clause of the contract, the body of the function (or loop) is instrumented with assertion statements before each statement which may write to memory (e.g., an assignment). These assertions check that the location about to be assigned to is among the targets specified by the <em>assigns</em> clauses.</p>
<p>For example, consider the following implementation of <code>sum</code> function.</p>
<div class="fragment"><div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">/* Writable Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Assignable locations for the <code>sum</code> function are the locations specified with <code>__CPROVER_assigns</code>, together with any location storing a function parameter, or any location that is locally stack- or heap-allocated as part of function (or loop) execution.</p>
<p>In the case of <code>sum</code> that is <code>*out</code> and <code>result</code>. Each assignment will be instrumented with an assertion to check that the target of the assignment is one of those options.</p>
<div class="fragment"><div class="line">int __CPROVER_contracts_original_sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result;</div>
<div class="line">  __CPROVER_assert((__CPROVER_POINTER_OBJECT(&amp;result) == __CPROVER_POINTER_OBJECT(out)  &amp;&amp;</div>
<div class="line">                    __CPROVER_POINTER_OFFSET(&amp;result) == __CPROVER_POINTER_OFFSET(out)) ||</div>
<div class="line">                   (__CPROVER_POINTER_OBJECT(&amp;result) == __CPROVER_POINTER_OBJECT(&amp;result)  &amp;&amp;</div>
<div class="line">                    __CPROVER_POINTER_OFFSET(&amp;result) == __CPROVER_POINTER_OFFSET(&amp;result))</div>
<div class="line">                   , &quot;Check that result is assignable&quot;);</div>
<div class="line">  result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  __CPROVER_assert((__CPROVER_POINTER_OBJECT(out) == __CPROVER_POINTER_OBJECT(out)  &amp;&amp;</div>
<div class="line">                     __CPROVER_POINTER_OFFSET(out) == __CPROVER_POINTER_OFFSET(out)) ||</div>
<div class="line">                    (__CPROVER_POINTER_OBJECT(out) == __CPROVER_POINTER_OBJECT(&amp;result)  &amp;&amp;</div>
<div class="line">                     __CPROVER_POINTER_OFFSET(out) == __CPROVER_POINTER_OFFSET(&amp;result))</div>
<div class="line">                    , &quot;Check that result is assignable&quot;);</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/* Function Contract Enforcement */</div>
<div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">{</div>
<div class="line">  int return_value_sum = __CPROVER_contracts_original_sum(a, b, out);</div>
<div class="line">  return return_value_sum;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="contract-replacement"></a>
Contract Replacement</h3>
<p>Assuming the <em>assigns</em> clause of the contract correctly captures the set of locations assigned to by a function (checked during <em>contract enforcement</em>), CBMC will use the contract’s <a href="contracts-requires-and-ensures.md#replacement">Requires &amp; Ensures Clauses</a>, and its <em>assigns clause</em> to generate a sound abstraction of the function behaviour from the contract.</p>
<p>Given the contract:</p>
<div class="fragment"><div class="line">int f(params)</div>
<div class="line">__CPROVER_requires(R);</div>
<div class="line">__CPROVER_assigns(A);</div>
<div class="line">__CPROVER_ensures(E);</div>
<div class="line">{ ... }</div>
</div><!-- fragment --><p>Function calls <code>f(args)</code> get replaced with a sequence of instuctions equivalent to:</p>
<div class="fragment"><div class="line">// check preconditions</div>
<div class="line">__CPROVER_assert(R[args/params], &quot;Check f preconditions&quot;);</div>
<div class="line"> </div>
<div class="line">// havoc the assignable targets</div>
<div class="line">// for each target t1, t2, ... of A[args/params];</div>
<div class="line">t1 = nondet();</div>
<div class="line">t2 = nondet();</div>
<div class="line">...</div>
<div class="line">// assume post conditions</div>
<div class="line">__CPROVER_assume(E[args/params]);</div>
</div><!-- fragment --><p>Where <code>R[args/params]</code>, <code>A[args/params]</code>, <code>E[args/params]</code> denote the contract clause expressions rewritten by substituting function parameters with the argyments passed at the call site.</p>
<p>In our example, consider that a function <code>foo</code> may call <code>sum</code>.</p>
<div class="fragment"><div class="line">int sum(const uint32_t a, const uint32_t b, uint32_t* out)</div>
<div class="line">/* Preconditions */</div>
<div class="line">__CPROVER_requires(__CPROVER_is_fresh(out, sizeof(*out)))</div>
<div class="line">/* Postconditions */</div>
<div class="line">__CPROVER_ensures(__CPROVER_return_value == SUCCESS || __CPROVER_return_value == FAILURE)</div>
<div class="line">__CPROVER_ensures((__CPROVER_return_value == SUCCESS) ==&gt; (*out == (a + b)))</div>
<div class="line">/* Writable Set */</div>
<div class="line">__CPROVER_assigns(*out)</div>
<div class="line">{</div>
<div class="line">  const uint64_t result = ((uint64_t) a) + ((uint64_t) b);</div>
<div class="line">  if (result &gt; UINT32_MAX) return FAILURE;</div>
<div class="line">  *out = (uint32_t) result;</div>
<div class="line">  return SUCCESS;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">int foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line">  int rval = sum(a, b, &amp;out);</div>
<div class="line">  if (rval == SUCCESS)</div>
<div class="line">    return out;</div>
<div class="line">  return rval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>CBMC will use the function contract in place of the function implementation wherever the function is called.</p>
<div class="fragment"><div class="line">int foo()</div>
<div class="line">{</div>
<div class="line">  uint32_t a;</div>
<div class="line">  uint32_t b;</div>
<div class="line">  uint32_t out;</div>
<div class="line"> </div>
<div class="line">  /* Function Contract Replacement */</div>
<div class="line">  /* Precondition */</div>
<div class="line">  __CPROVER_assert(__CPROVER_is_fresh(out, sizeof(*out)), &quot;Check requires clause&quot;);</div>
<div class="line"> </div>
<div class="line">  /* Writable Set */</div>
<div class="line">  *(&amp;out) = nondet_uint32_t();</div>
<div class="line"> </div>
<div class="line">  /* Postconditions */</div>
<div class="line">  int return_value_sum = nondet_int();</div>
<div class="line">  __CPROVER_assume(return_value_sum == SUCCESS || return_value_sum == FAILURE);</div>
<div class="line">  __CPROVER_assume((return_value_sum == SUCCESS) ==&gt; (*out == (a + b)));</div>
<div class="line"> </div>
<div class="line">  int rval = return_value_sum;</div>
<div class="line">  if (rval == SUCCESS)</div>
<div class="line">    return out;</div>
<div class="line">  return rval;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Last modified: 2022-10-26 23:34:07 +0100 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
