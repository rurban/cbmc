<h1>NAME</h1>
<p>cbmc - Bounded Model Checker for C/C++ and Java programs</p>
<h1>SYNOPSIS</h1>
<p><strong>cbmc [--property <em>property-id</em><strong>]</strong> <em>file.c</em> ...</strong></p>
<p><strong>cbmc [--show-properties] <em>file.c</em> ...</strong></p>
<p><strong>cbmc [--all-properties] <em>file.c</em> ...</strong></p>
<p><strong>goto-cc [-I <em>include-path</em><strong>]</strong> [-c] <em>file.c</em> [-o <em>outfile.o</em><strong>]</strong></strong></p>
<p><strong>goto-instrument <em>infile</em> <em>outfile</em></strong></p>
<p>Only the most useful options are listed here; see below for the remainder.</p>
<h1>DESCRIPTION</h1>
<p><strong>cbmc</strong> generates traces that demonstrate how an assertion can be violated, or proves that the assertion cannot be violated within a given number of loop iterations. CBMC can read C/C++ source-code directly, or a goto-binary generated by goto-cc. Java programs are given as class or JAR files. Without any further options, cbmc checks all properties (automatically generated or user-specified) found in the program. If any of the properties can be violated, a counterexample is printed and the analysis is aborted. The analysis can be restricted to a particular property with the --property option. The verification result for all properties can be obtained by means of the --all-properties option.</p>
<p><strong>goto-cc</strong> reads source code, and generates a goto-binary. Its command-line interface is designed to mimic that of <strong>gcc</strong>(1). Note in particular that <strong>goto-cc</strong> distinguishes between compiling and linking phases, just as gcc does. <strong>cbmc</strong> expects a goto-binary for which linking has been completed.</p>
<p><strong>goto-instrument</strong> reads a goto-binary, performs a given program transformation, and then writes the resulting program as goto-binary on disc.</p>
<p>The usual flow is to (1) translate source into a goto-binary using goto-cc, then (2) perform instrumentation with goto-instrument, and finally (3) perform the analysis with cbmc.</p>
<h1>OPTIONS</h1>
<h2>FRONTEND OPTIONS (cbmc and goto-cc)</h2>
<ul>
<li><p>Set include path (C/C++)</p></li>
<li><p>Define preprocessor macro (C/C++)</p></li>
<li><p>Stop after preprocessing</p></li>
<li><p>Show symbol table</p></li>
<li><p>Show goto program</p></li>
</ul>
<h2>ARCHITECTURAL OPTIONS (cbmc and goto-cc)</h2>
<p><strong>cbmc</strong> by default uses architectural settings that match those of the machine <strong>cbmc</strong> is executed on, i.e., the settings below are only needed when verifying software that is meant to run on a different architecture or OS. <strong>goto-cc</strong> generates a goto-binary for a particular architecture, i.e., the architecture cannot be changed after the goto-binary is generated.</p>
<ul>
<li><p>Set width of int</p></li>
<li><p>Set width of int, long and pointers</p></li>
<li><p>Allow little-endian word-byte conversions</p></li>
<li><p>Allow big-endian word-byte conversions</p></li>
<li><p>Make "char" unsigned by default</p></li>
<li><p>Set target architecture</p></li>
<li><p>Set target operating system</p></li>
<li><p>Disable built-in abstract C library</p></li>
<li><p>IEEE floating point rounding mode to use when the program begins (default is round to nearest). The program under verification can override this setting, e.g., with <strong>fesetround</strong>(3).</p></li>
</ul>
<h2>PROGRAM INSTRUMENTATION OPTIONS (cbmc and goto-instrument)</h2>
<p>Both <strong>cbmc</strong> and <strong>goto-instrument</strong> can generate assertions that catch specific common errors, as listed below.</p>
<ul>
<li><p>Enable array bounds checks</p></li>
<li><p>Enable division by zero checks</p></li>
<li><p>Enable pointer checks</p></li>
<li><p>Enable arithmetic over- and underflow checks for signed integer arithmetic</p></li>
<li><p>Enable arithmetic over- and underflow checks for unsigned integer arithmetic</p></li>
<li><p>Check floating-point computations for NaN</p></li>
<li><p>Ignore user-provided assertions</p></li>
<li><p>Ignore user-provided assumptions</p></li>
<li><p>Check that the given label is unreachable</p></li>
</ul>
<h2>PROGRAM INSTRUMENTATION OPTIONS (goto-instrument only)</h2>
<p><strong>goto-instrument</strong> supports further, more complex, program transformations.</p>
<ul>
<li><p>Makes reads from volatile variables non-deterministic</p></li>
<li><p>Instruments an interrupt service routine with the given name</p></li>
<li><p>Instruments memory-mapped I/O</p></li>
<li><p>Variables with static lifetime are initialized non-deterministically</p></li>
<li><p>Output ANSI-C source code instead of a goto binary.</p></li>
</ul>
<h2>BMC OPTIONS (cbmc)</h2>
<ul>
<li><p>Report status of all properties</p></li>
<li><p>Only show properties</p></li>
<li><p>Show the loops in the program</p></li>
<li><p>Check which assertions are reachable</p></li>
<li><p>Set main function name</p></li>
<li><p>Only check specific property with given identifier</p></li>
<li><p>Only show program expression</p></li>
<li><p>Limit search depth</p></li>
<li><p>Unwind loops nr times</p></li>
<li><p>Unwind loop L with a bound of B, optionally restricted to thread T. Use --show-loops to get the loop IDs. Thread numbers are set as follows: The initial thread has index 0, and threads are consecutively numbered in program order of threads being spawned. The`--unwindset` option can be given multiple times.</p></li>
<li><p>Show the verification conditions</p></li>
<li><p>Remove assignments unrelated to property</p></li>
<li><p>Do not generate unwinding assertions</p></li>
</ul>
<h2>BACKEND OPTIONS (cbmc)</h2>
<ul>
<li><p>Generate CNF in DIMACS format for use by external SAT solvers</p></li>
<li><p>Beautify the counterexample (greedy heuristic)</p></li>
<li><p>Output subgoals in SMT2 syntax</p></li>
<li><p>Use Boolector (experimental)</p></li>
<li><p>Use MathSAT (experimental)</p></li>
<li><p>Use CVC3 (experimental)</p></li>
<li><p>Use CVC4 (experimental)</p></li>
<li><p>Use Yices (experimental)</p></li>
<li><p>Use Z3 (experimental)</p></li>
<li><p>Use refinement procedure (experimental)</p></li>
<li><p>Output formula to given file</p></li>
<li><p>Never turn arrays into uninterpreted functions</p></li>
<li><p>Always turn arrays into uninterpreted functions</p></li>
<li><p>Use the incremental SMT backend where &lt;cmd&gt; is the command to invoke the SMT solver of choice.<br />
Examples invocations:<br />
--incremental-smt2-solver 'z3 -smt2 -in' (use the Z3 solver).<br />
--incremental-smt2-solver 'cvc5 --lang=smtlib2.6 --incremental' (use the CVC5 solver).</p></li>
</ul>
<p>Note that:<br />
The solver name must be in the "PATH" or be an executable with full path.<br />
The SMT solver should accept incremental SMTlib v2.6 formatted input from the stdin.<br />
The SMT solver should support the QF_AUFBV logic.<br />
The flag --slice-formula should be added to remove some not-yet supported features.</p>
<h1>ENVIRONMENT</h1>
<p>All tools honor the TMPDIR environment variable when generating temporary files and directories. Furthermore note that the preprocessor used by CBMC will use environment variables to locate header files. GOTO-CC aims to accept all environment variables that GCC does.</p>
<h1>COPYRIGHT</h1>
<p>2001-2016, Daniel Kroening, Edmund Clarke</p>
